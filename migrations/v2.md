# v2 Migration Notes

The following is documentation on what changed between v1 and v2 of `ngx-form-signal` and what behavior/breaking changes to look out for

## input.required

formSignal now supports consuming required input signals. In v1, the form was eagerly read to set the initial values of the various value, rawValue, dirty, touched, etc... states. This broke with required inputs because reading of a required input before the ngOnInit lifecycle would error.

This means you no longer have to do things like:

```typescript
@Component({...})
export class SimpleExampleComponent {
   readonly form = input<FormGroup<...> | null>(null)
   readonly formSignal = formSignal(form)
}
```

and can do something like this instead

```typescript
@Component({...})
export class SimpleExampleComponent {
   readonly form = input.required<FormGroup<...>>()
   readonly formSignal = formSignal(form)
}
```

Note using a required input will put null and other falsy values into the intneral signals initially so you still need to handle this when deriving/reacting to values pre ngOnInit, but the change here was primarily to catch the input read error since it more often than not makes more since to have a required input with null internal initial states than not be able to use a required input at all.

## Deep form signal

Deep form signal had a few updates.

First the way to access nested formSignals changed from using the `children` field to using the `controls` field. This is more inline with reactive forms api.

This controls field was also updated to handle dynamic forms better by tying into value and status changes. This caused some other edge cases described in the [readme](../README.md#deep-form-signal-example) around proxying and what not, but generally the interaction with the deep form signal is the same beyond that field change.

## EagerNotify instead of equality functions

In v1 all internal signals had their equality fns set to `{ equal: () => false }` by default. This made these internal signals notify their consumers as often (or close to as often) to how often valueChanges, and other form events notify their consumers.

This is no longer the case in v2. The internal signals now use the default signal equality comparisions instead. If you want to get a similar behavior to the old v1 default, set the new `eagerNotify` flag in the input options to true.

The addition of this flag also removes the old `equalityFns` input. If you want to make a custom equality function for some signal the formSignal helper exposes you can opt in to eagerNotify, then write a computed off the eagerly notifying internal signal with the custom equality function you want instead.

This reduces complexity of the input interface of formSignal and gets closer to "normal" signal behaviors by default

```typescript
@Component({...})
export class SimpleExampleComponent {
   readonly form = new FormControl<string | null>("test")
   readonly eagerFormSignal = formSignal(form, { eagerNotify: true })
   readonly formSignal = formSignal(form, { eagerNotify: false }) // default options

   readonly someEffectForEagerSignal = effect(() => {
      console.log(this.eagerFormSignal.value()) // logs for both setValue calls
   })
   readonly someEffectForNormalSignal = effect(() => {
      console.log(this.formSignal.value()) // logs for first setValue call (not second because the value was the same as it was before)
   })

   ngOnInit() {
      this.form.setValue("test2")
      setTimeout(() => {
         this.form.setValue("test2")
      }, 5000)
   }
}
```
